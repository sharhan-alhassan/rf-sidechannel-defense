/*
 * ESP32 Random Forest Side-Channel Detector
 * Accuracy: 80.6% (trained on real ESP32 power measurements)
 * 
 * Perfect detection for:
 * - VIDEO streaming: 100% F1
 * - GAMING: 100% F1
 * - SOCIAL media: 90% F1
 * 
 * WIRING:
 * ESP32 3.3V ‚Üí 10kŒ© ‚Üí GPIO34 (ADC) ‚Üí 10kŒ© ‚Üí GND
 * OLED SDA ‚Üí GPIO21
 * OLED SCL ‚Üí GPIO22
 * 
 * NO EXTERNAL LIBRARIES NEEDED (except U8g2 for OLED)
 */

 #include <WiFi.h>
 #include <Wire.h>
 #include <U8g2lib.h>
 #include "random_forest_model.h"  // Generated by extract_rf_to_cpp.py
 
 // ============ CONFIGURATION ============
 #define WIFI_SSID "CBTECH_OPEN_STARLINK"
 #define WIFI_PASSWORD "Mamalove@2020"
 
 #define ADC_PIN 34
 #define SDA_PIN 21
 #define SCL_PIN 22
 #define MITIGATION_PIN 25  // Optional: GPIO for countermeasure
 
 #define SAMPLE_RATE 200
 #define WINDOW_SIZE 100
 #define NUM_FEATURES 30
 
 // ============ HARDWARE ============
 U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, U8X8_PIN_NONE);
 
 // ============ FEATURE EXTRACTION ============
 class FeatureExtractor {
 private:
   float window[WINDOW_SIZE];
   int window_idx = 0;
   
 public:
   void add_sample(float voltage) {
     window[window_idx] = voltage;
     window_idx = (window_idx + 1) % WINDOW_SIZE;
   }
   
   bool is_window_ready() {
     return window_idx == 0;
   }
   
   void extract_features(float* features) {
     // Time-domain features (14)
     float sum = 0, sum_sq = 0, min_v = 99999, max_v = -99999;
     
     for(int i = 0; i < WINDOW_SIZE; i++) {
       sum += window[i];
       sum_sq += window[i] * window[i];
       if(window[i] < min_v) min_v = window[i];
       if(window[i] > max_v) max_v = window[i];
     }
     
     float mean = sum / WINDOW_SIZE;
     float var = (sum_sq / WINDOW_SIZE) - (mean * mean);
     float std = sqrt(var);
     
     features[0] = mean;
     features[1] = std;
     features[2] = var;
     features[3] = min_v;
     features[4] = max_v;
     features[5] = max_v - min_v;  // range
     features[6] = calculate_median();
     features[7] = calculate_skewness(mean, std);
     features[8] = calculate_kurtosis(mean, std);
     features[9] = calculate_percentile(25);
     features[10] = calculate_percentile(75);
     
     // Derivative features (3)
     float diff_sum = 0, diff_sum_sq = 0, max_diff = 0;
     for(int i = 1; i < WINDOW_SIZE; i++) {
       float d = abs(window[i] - window[i-1]);
       diff_sum += d;
       diff_sum_sq += d * d;
       if(d > max_diff) max_diff = d;
     }
     features[11] = diff_sum / (WINDOW_SIZE - 1);
     features[12] = sqrt((diff_sum_sq / (WINDOW_SIZE - 1)) - (features[11] * features[11]));
     features[13] = max_diff;
     
     // Frequency-domain features (10) - Simplified
     float energy_low = 0, energy_mid = 0, energy_high = 0;
     for(int i = 0; i < WINDOW_SIZE/2; i++) {
       float val = abs(window[i] - window[i + WINDOW_SIZE/2]);
       if(i < 10) energy_low += val;
       else if(i < 50) energy_mid += val;
       else energy_high += val;
     }
     
     features[14] = energy_low;
     features[15] = energy_mid;
     features[16] = energy_high;
     features[17] = energy_low + energy_mid + energy_high;
     features[18] = std;  // Spectral spread approximation
     features[19] = max_v - min_v;  // Spectral range
     features[20] = 0;  // Placeholder for full FFT features
     features[21] = 0;
     features[22] = 0;
     features[23] = 0;
     
     // Wavelet features (6) - Simplified Haar decomposition
     float approx[WINDOW_SIZE/2], detail[WINDOW_SIZE/2];
     for(int i = 0; i < WINDOW_SIZE/2; i++) {
       approx[i] = (window[2*i] + window[2*i+1]) / 2.0;
       detail[i] = (window[2*i] - window[2*i+1]) / 2.0;
     }
     
     float approx_sum = 0, approx_sum_sq = 0;
     float detail_sum = 0, detail_sum_sq = 0;
     float detail_energy1 = 0, detail_energy2 = 0;
     
     for(int i = 0; i < WINDOW_SIZE/2; i++) {
       approx_sum += approx[i];
       approx_sum_sq += approx[i] * approx[i];
       detail_sum += detail[i];
       detail_sum_sq += detail[i] * detail[i];
       
       if(i < WINDOW_SIZE/4) detail_energy1 += abs(detail[i]);
       else detail_energy2 += abs(detail[i]);
     }
     
     float approx_mean = approx_sum / (WINDOW_SIZE/2);
     float detail_mean = detail_sum / (WINDOW_SIZE/2);
     
     features[24] = sqrt((approx_sum_sq / (WINDOW_SIZE/2)) - (approx_mean * approx_mean));
     features[25] = sqrt((detail_sum_sq / (WINDOW_SIZE/2)) - (detail_mean * detail_mean));
     features[26] = features[25] * 0.7;  // Approximation for level 2
     features[27] = features[25] * 0.5;  // Approximation for level 3
     features[28] = detail_energy1;
     features[29] = detail_energy2;
   }
 
 private:
   float calculate_median() {
     float temp[WINDOW_SIZE];
     memcpy(temp, window, WINDOW_SIZE * sizeof(float));
     
     // Partial sort to find median
     for(int i = 0; i < WINDOW_SIZE/2 + 1; i++) {
       for(int j = i + 1; j < WINDOW_SIZE; j++) {
         if(temp[j] < temp[i]) {
           float swap = temp[i];
           temp[i] = temp[j];
           temp[j] = swap;
         }
       }
     }
     return temp[WINDOW_SIZE/2];
   }
   
   float calculate_percentile(int p) {
     float temp[WINDOW_SIZE];
     memcpy(temp, window, WINDOW_SIZE * sizeof(float));
     
     int target = (p * WINDOW_SIZE) / 100;
     
     // Partial sort to target index
     for(int i = 0; i < target + 1; i++) {
       for(int j = i + 1; j < WINDOW_SIZE; j++) {
         if(temp[j] < temp[i]) {
           float swap = temp[i];
           temp[i] = temp[j];
           temp[j] = swap;
         }
       }
     }
     return temp[target];
   }
   
   float calculate_skewness(float mean, float std) {
     if(std == 0) return 0;
     
     float sum_cubed = 0;
     for(int i = 0; i < WINDOW_SIZE; i++) {
       float z = (window[i] - mean) / std;
       sum_cubed += z * z * z;
     }
     return sum_cubed / WINDOW_SIZE;
   }
   
   float calculate_kurtosis(float mean, float std) {
     if(std == 0) return 0;
     
     float sum_fourth = 0;
     for(int i = 0; i < WINDOW_SIZE; i++) {
       float z = (window[i] - mean) / std;
       sum_fourth += z * z * z * z;
     }
     return (sum_fourth / WINDOW_SIZE) - 3.0;  // Excess kurtosis
   }
 };
 
 // ============ GLOBALS ============
 FeatureExtractor extractor;
 float features[NUM_FEATURES];
 
 unsigned long total_inferences = 0;
 unsigned long total_latency = 0;
 int detection_count[6] = {0};
 int last_predicted = -1;
 unsigned long last_change = 0;
 
 // ============ SETUP ============
 void setup() {
   Serial.begin(115200);
   delay(1000);
   
   Serial.println("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
   Serial.println("‚ïë  Random Forest Side-Channel Detector  ‚ïë");
   Serial.println("‚ïë  Accuracy: 80.6% | VIDEO/GAMING: 100% ‚ïë");
   Serial.println("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
   
   // ADC
   analogReadResolution(12);
   analogSetAttenuation(ADC_11db);
   Serial.println("‚úì ADC configured: GPIO34, 12-bit, 200Hz");
   
   // OLED
   Wire.begin(SDA_PIN, SCL_PIN);
   u8g2.begin();
   u8g2.setContrast(255);
   Serial.println("‚úì OLED initialized: 1.3\" SH1106");
   
   // Mitigation pin (optional)
   pinMode(MITIGATION_PIN, OUTPUT);
   digitalWrite(MITIGATION_PIN, LOW);
   
   show_boot_screen();
   
   // WiFi (optional for demo)
   Serial.print("Connecting WiFi...");
   WiFi.mode(WIFI_STA);
   WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
   
   int attempts = 0;
   while (WiFi.status() != WL_CONNECTED && attempts < 20) {
     delay(500);
     Serial.print(".");
     attempts++;
   }
   
   if(WiFi.status() == WL_CONNECTED) {
     Serial.println("\n‚úì WiFi connected");
     Serial.print("IP: ");
     Serial.println(WiFi.localIP());
   } else {
     Serial.println("\n‚ö† WiFi not connected (demo mode)");
   }
   
   Serial.println("\nüå≤ Random Forest Model Loaded");
   Serial.println("   Algorithm: Decision Tree (from RF ensemble)");
   Serial.println("   Features: 30 (time + freq + wavelet)");
   Serial.println("   Classes: 6 activities");
   
   show_ready_screen();
   delay(2000);
   
   Serial.println("\n=== Real-time Inference Started ===\n");
   Serial.println("Format: Inference# | Activity | Confidence | Latency");
 }
 
 // ============ MAIN LOOP ============
 void loop() {
   static unsigned long last_sample = 0;
   unsigned long now = millis();
   
   // Sample at 200Hz
   if (now - last_sample >= 5) {
     last_sample = now;
     
     int adc = analogRead(ADC_PIN);
     float voltage = (adc / 4095.0) * 3300.0;
     
     extractor.add_sample(voltage);
     
     if (extractor.is_window_ready()) {
       run_inference();
     }
   }
 }
 
 // ============ INFERENCE ============
 void run_inference() {
   unsigned long start = micros();
   
   // Extract features
   extractor.extract_features(features);
   
   // Run Random Forest classifier
   int predicted_class = classify_random_forest(features);
   
   unsigned long latency = micros() - start;
   total_latency += latency;
   total_inferences++;
   detection_count[predicted_class]++;
   
   // Detect activity changes
   bool activity_changed = (predicted_class != last_predicted);
   if(activity_changed) {
     last_predicted = predicted_class;
     last_change = millis();
   }
   
   // Log to Serial
   Serial.print("#");
   Serial.print(total_inferences);
   Serial.print(" | ");
   Serial.print(activity_names[predicted_class]);
   Serial.print(" | Latency: ");
   Serial.print(latency / 1000.0, 2);
   Serial.print(" ms | Avg: ");
   Serial.print((total_latency / total_inferences) / 1000.0, 2);
   Serial.println(" ms");
   
   // Log features every 10 inferences (for debugging)
   if(total_inferences % 10 == 0) {
     Serial.print("   [Features] mean=");
     Serial.print(features[0], 1);
     Serial.print(" std=");
     Serial.print(features[1], 1);
     Serial.print(" range=");
     Serial.print(features[5], 1);
     Serial.print(" energy_mid=");
     Serial.println(features[15], 1);
   }
   
   // Trigger mitigation if attack detected
   if(predicted_class != 0 && activity_changed) {
     trigger_mitigation(predicted_class);
   }
   
   // Update display
   update_display(predicted_class, latency, activity_changed);
 }
 
 // ============ MITIGATION ============
 void trigger_mitigation(int attack_type) {
   Serial.print("‚ö†Ô∏è  MITIGATION: ");
   Serial.print(activity_names[attack_type]);
   Serial.println(" side-channel detected!");
   
   // Inject power noise to mask side-channel
   for(int i = 0; i < 15; i++) {
     digitalWrite(MITIGATION_PIN, HIGH);
     delayMicroseconds(random(50, 200));
     digitalWrite(MITIGATION_PIN, LOW);
     delayMicroseconds(random(50, 200));
   }
 }
 
 // ============ DISPLAY ============
 void show_boot_screen() {
   u8g2.clearBuffer();
   u8g2.setFont(u8g2_font_logisoso16_tr);
   u8g2.drawStr(5, 28, "SIDE-CHANNEL");
   u8g2.setFont(u8g2_font_7x13B_tr);
   u8g2.drawStr(25, 48, "DEFENDER");
   u8g2.setFont(u8g2_font_5x7_tr);
   u8g2.drawStr(20, 60, "Random Forest 80.6%");
   u8g2.sendBuffer();
   delay(2000);
 }
 
 void show_ready_screen() {
   u8g2.clearBuffer();
   u8g2.setFont(u8g2_font_7x13B_tr);
   u8g2.drawStr(30, 24, "READY");
   u8g2.setFont(u8g2_font_6x10_tr);
   u8g2.drawStr(5, 40, "Random Forest");
   u8g2.drawStr(5, 52, "Decision Tree");
   u8g2.drawStr(5, 64, "30 features, 6 classes");
   u8g2.sendBuffer();
 }
 
 void update_display(int cls, unsigned long latency_us, bool changed) {
   u8g2.clearBuffer();
   
   // Header
   u8g2.setFont(u8g2_font_6x10_tr);
   u8g2.drawStr(0, 10, "LIVE DETECTION");
   u8g2.drawLine(0, 11, 128, 11);
   
   // Activity name (large)
   u8g2.setFont(u8g2_font_9x15B_tr);
   u8g2.setCursor(0, 28);
   u8g2.print(activity_names[cls]);
   
   // Alert border if not IDLE
   if (cls != 0) {
     // Flashing border animation
     if((millis() / 300) % 2 || changed) {
       u8g2.drawFrame(0, 0, 128, 64);
       u8g2.drawFrame(1, 1, 126, 62);
     }
     
     u8g2.setFont(u8g2_font_6x10_tr);
     u8g2.drawStr(85, 10, "ALERT");
   }
   
   // Stats
   u8g2.setFont(u8g2_font_5x7_tr);
   
   u8g2.setCursor(0, 42);
   u8g2.print("Latency: ");
   u8g2.print(latency_us / 1000.0, 1);
   u8g2.print(" ms");
   
   u8g2.setCursor(0, 52);
   u8g2.print("Count: ");
   u8g2.print(total_inferences);
   
   // Detection distribution (mini bar chart)
   u8g2.setCursor(0, 62);
   u8g2.print("Dist:");
   for(int i = 0; i < 6; i++) {
     int bar_height = map(detection_count[i], 0, max(1, total_inferences/6), 0, 8);
     u8g2.drawBox(30 + i*16, 62 - bar_height, 14, bar_height);
   }
   
   u8g2.sendBuffer();
 }