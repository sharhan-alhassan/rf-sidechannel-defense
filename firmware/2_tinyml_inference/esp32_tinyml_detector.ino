/*
 * ESP32 TinyML Side-Channel Detector - Phase 3
 * Real-time inference using TensorFlow Lite Micro
 * 
 * WIRING: Same as data collection
 * ESP32 3.3V â†’ 10kÎ© â†’ GPIO34 â†’ 10kÎ© â†’ GND
 * OLED: SDA=21, SCL=22
 * 
 * LIBRARIES NEEDED (Arduino IDE):
 * 1. Install "EloquentTinyML" by Eloquent Arduino
 *    OR
 * 2. TensorFlowLite_ESP32 (if using official TFLM)
 */

 #include <WiFi.h>
 #include <Wire.h>
 #include <U8g2lib.h>
 
 // TinyML - Choose ONE of these options:
 // Option A: EloquentTinyML (easier, recommended)
 #include <EloquentTinyML.h>
 #include "model.h"  // Generated by Python script
 
 // Option B: Official TensorFlow Lite Micro
 // #include <TensorFlowLite_ESP32.h>
 // #include "tensorflow/lite/micro/all_ops_resolver.h"
 // #include "tensorflow/lite/micro/micro_error_reporter.h"
 // #include "tensorflow/lite/micro/micro_interpreter.h"
 // #include "tensorflow/lite/schema/schema_generated.h"
 
 // ============ CONFIGURATION ============
 #define WIFI_SSID "CBTECH_OPEN_STARLINK"
 #define WIFI_PASSWORD "Mamalove@2020"
 
 #define ADC_PIN 34
 #define SDA_PIN 21
 #define SCL_PIN 22
 
 #define SAMPLE_RATE 200
 #define WINDOW_SIZE 100
 #define NUM_FEATURES 30
 
 // ============ HARDWARE ============
 U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, U8X8_PIN_NONE);
 
 // ============ TINYML MODEL ============
 #define ARENA_SIZE 20000
 Eloquent::TinyML::TfLite<NUM_FEATURES, 6, ARENA_SIZE> ml(model_data);
 
 // ============ FEATURE EXTRACTION ============
 class FeatureExtractor {
 private:
   float window[WINDOW_SIZE];
   int window_idx = 0;
   
 public:
   void add_sample(float voltage) {
     window[window_idx] = voltage;
     window_idx = (window_idx + 1) % WINDOW_SIZE;
   }
   
   bool is_window_ready() {
     return window_idx == 0;
   }
   
   void extract_features(float* features) {
     // Time-domain features (14)
     features[0] = calculate_mean(window, WINDOW_SIZE);
     features[1] = calculate_std(window, WINDOW_SIZE);
     features[2] = calculate_var(window, WINDOW_SIZE);
     features[3] = calculate_min(window, WINDOW_SIZE);
     features[4] = calculate_max(window, WINDOW_SIZE);
     features[5] = calculate_range(window, WINDOW_SIZE);
     features[6] = calculate_median(window, WINDOW_SIZE);
     features[7] = calculate_skewness(window, WINDOW_SIZE);
     features[8] = calculate_kurtosis(window, WINDOW_SIZE);
     features[9] = calculate_percentile(window, WINDOW_SIZE, 25);
     features[10] = calculate_percentile(window, WINDOW_SIZE, 75);
     
     // Derivatives
     float diff[WINDOW_SIZE-1];
     for(int i = 0; i < WINDOW_SIZE-1; i++) {
       diff[i] = window[i+1] - window[i];
     }
     features[11] = calculate_mean_abs(diff, WINDOW_SIZE-1);
     features[12] = calculate_std(diff, WINDOW_SIZE-1);
     features[13] = calculate_max_abs(diff, WINDOW_SIZE-1);
     
     // Frequency-domain features (10) - Simplified FFT
     extract_fft_features(window, WINDOW_SIZE, &features[14]);
     
     // Wavelet features (6) - Simplified
     extract_wavelet_features(window, WINDOW_SIZE, &features[24]);
   }
   
 private:
   float calculate_mean(float* data, int len) {
     float sum = 0;
     for(int i = 0; i < len; i++) sum += data[i];
     return sum / len;
   }
   
   float calculate_std(float* data, int len) {
     float mean = calculate_mean(data, len);
     float sum_sq = 0;
     for(int i = 0; i < len; i++) {
       float diff = data[i] - mean;
       sum_sq += diff * diff;
     }
     return sqrt(sum_sq / len);
   }
   
   float calculate_var(float* data, int len) {
     float std = calculate_std(data, len);
     return std * std;
   }
   
   float calculate_min(float* data, int len) {
     float min_val = data[0];
     for(int i = 1; i < len; i++) {
       if(data[i] < min_val) min_val = data[i];
     }
     return min_val;
   }
   
   float calculate_max(float* data, int len) {
     float max_val = data[0];
     for(int i = 1; i < len; i++) {
       if(data[i] > max_val) max_val = data[i];
     }
     return max_val;
   }
   
   float calculate_range(float* data, int len) {
     return calculate_max(data, len) - calculate_min(data, len);
   }
   
   float calculate_median(float* data, int len) {
     // Simple approximation using sorted subset
     float temp[WINDOW_SIZE];
     memcpy(temp, data, len * sizeof(float));
     
     // Bubble sort (simple for small arrays)
     for(int i = 0; i < len-1; i++) {
       for(int j = 0; j < len-i-1; j++) {
         if(temp[j] > temp[j+1]) {
           float swap = temp[j];
           temp[j] = temp[j+1];
           temp[j+1] = swap;
         }
       }
     }
     
     return temp[len/2];
   }
   
   float calculate_skewness(float* data, int len) {
     float mean = calculate_mean(data, len);
     float std = calculate_std(data, len);
     
     float sum_cubed = 0;
     for(int i = 0; i < len; i++) {
       float diff = (data[i] - mean) / std;
       sum_cubed += diff * diff * diff;
     }
     
     return sum_cubed / len;
   }
   
   float calculate_kurtosis(float* data, int len) {
     float mean = calculate_mean(data, len);
     float std = calculate_std(data, len);
     
     float sum_fourth = 0;
     for(int i = 0; i < len; i++) {
       float diff = (data[i] - mean) / std;
       sum_fourth += diff * diff * diff * diff;
     }
     
     return (sum_fourth / len) - 3.0;  // Excess kurtosis
   }
   
   float calculate_percentile(float* data, int len, int percentile) {
     float temp[WINDOW_SIZE];
     memcpy(temp, data, len * sizeof(float));
     
     // Sort
     for(int i = 0; i < len-1; i++) {
       for(int j = 0; j < len-i-1; j++) {
         if(temp[j] > temp[j+1]) {
           float swap = temp[j];
           temp[j] = temp[j+1];
           temp[j+1] = swap;
         }
       }
     }
     
     int idx = (percentile * len) / 100;
     return temp[idx];
   }
   
   float calculate_mean_abs(float* data, int len) {
     float sum = 0;
     for(int i = 0; i < len; i++) {
       sum += abs(data[i]);
     }
     return sum / len;
   }
   
   float calculate_max_abs(float* data, int len) {
     float max_val = abs(data[0]);
     for(int i = 1; i < len; i++) {
       float abs_val = abs(data[i]);
       if(abs_val > max_val) max_val = abs_val;
     }
     return max_val;
   }
   
   void extract_fft_features(float* data, int len, float* features) {
     // Simplified FFT features (approximation for embedded)
     // In production, use a proper FFT library like arduinoFFT
     
     // For now, use frequency-based approximations
     float sum_low = 0, sum_mid = 0, sum_high = 0;
     
     for(int i = 0; i < len/2; i++) {
       float val = abs(data[i] - data[i + len/2]);
       
       if(i < 10) sum_low += val;
       else if(i < 50) sum_mid += val;
       else sum_high += val;
     }
     
     features[0] = sum_low;   // Low freq energy
     features[1] = sum_mid;   // Mid freq energy
     features[2] = sum_high;  // High freq energy
     features[3] = sum_low + sum_mid + sum_high;  // Total energy
     features[4] = calculate_std(data, len);  // Spectral spread
     features[5] = calculate_range(data, len); // Spectral range
     features[6] = 0;  // Dominant freq (placeholder)
     features[7] = 0;  // Peak magnitude (placeholder)
     features[8] = 0;  // Centroid (placeholder)
     features[9] = 0;  // Rolloff (placeholder)
   }
   
   void extract_wavelet_features(float* data, int len, float* features) {
     // Simplified wavelet approximation (Haar-like)
     // Decompose into approximation and detail coefficients
     
     float approx[len/2];
     float detail[len/2];
     
     for(int i = 0; i < len/2; i++) {
       approx[i] = (data[2*i] + data[2*i+1]) / 2.0;
       detail[i] = (data[2*i] - data[2*i+1]) / 2.0;
     }
     
     features[0] = calculate_std(approx, len/2);
     features[1] = calculate_std(detail, len/2);
     features[2] = calculate_mean_abs(detail, len/2);
     features[3] = calculate_max_abs(detail, len/2);
     features[4] = calculate_var(approx, len/2);
     features[5] = calculate_var(detail, len/2);
   }
 };
 
 // ============ GLOBALS ============
 FeatureExtractor extractor;
 float features[NUM_FEATURES];
 
 unsigned long last_sample = 0;
 unsigned long last_inference = 0;
 int detection_count[6] = {0, 0, 0, 0, 0, 0};
 int total_inferences = 0;
 
 // ============ SETUP ============
 void setup() {
   Serial.begin(115200);
   delay(1000);
   
   Serial.println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
   Serial.println("â•‘   TinyML Side-Channel Detector v1.0   â•‘");
   Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
   
   // Configure ADC
   analogReadResolution(12);
   analogSetAttenuation(ADC_11db);
   Serial.println("âœ“ ADC configured");
   
   // Initialize OLED
   Wire.begin(SDA_PIN, SCL_PIN);
   u8g2.begin();
   u8g2.setContrast(255);
   Serial.println("âœ“ OLED initialized");
   
   show_boot_screen();
   
   // Connect WiFi
   Serial.print("Connecting WiFi...");
   WiFi.mode(WIFI_STA);
   WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
   
   int wifi_attempts = 0;
   while (WiFi.status() != WL_CONNECTED && wifi_attempts < 20) {
     delay(500);
     Serial.print(".");
     wifi_attempts++;
   }
   
   if(WiFi.status() == WL_CONNECTED) {
     Serial.println("\nâœ“ WiFi connected");
     Serial.print("IP: ");
     Serial.println(WiFi.localIP());
   } else {
     Serial.println("\nâš  WiFi not connected (continuing anyway)");
   }
   
   // Initialize TinyML model
   Serial.println("\nðŸ§  Loading TinyML model...");
   ml.begin();
   Serial.print("âœ“ Model loaded: ");
   Serial.print(model_data_len);
   Serial.print(" bytes (");
   Serial.print(model_data_len / 1024.0, 1);
   Serial.println(" KB)");
   
   show_ready_screen();
   delay(2000);
   
   Serial.println("\n=== Real-time Inference Started ===\n");
 }
 
 // ============ MAIN LOOP ============
 void loop() {
   unsigned long now = millis();
   
   // Sample at 200Hz
   if (now - last_sample >= 5) {  // 5ms = 200Hz
     last_sample = now;
     
     // Read voltage
     int adc_raw = analogRead(ADC_PIN);
     float voltage_mv = (adc_raw / 4095.0) * 3300.0;
     
     // Add to feature extractor
     extractor.add_sample(voltage_mv);
     
     // Run inference when window is ready
     if (extractor.is_window_ready()) {
       run_inference();
     }
   }
 }
 
 // ============ INFERENCE ============
 void run_inference() {
   unsigned long start_time = micros();
   
   // Extract features
   extractor.extract_features(features);
   
   // Run TinyML model
   int predicted_class = ml.predict(features);
   
   unsigned long inference_time = micros() - start_time;
   
   // Update statistics
   detection_count[predicted_class]++;
   total_inferences++;
   
   // Log to serial
   Serial.print("Inference #");
   Serial.print(total_inferences);
   Serial.print(" | Activity: ");
   Serial.print(activity_names[predicted_class]);
   Serial.print(" | Latency: ");
   Serial.print(inference_time / 1000.0, 2);
   Serial.println(" ms");
   
   // Update display
   update_display(predicted_class, inference_time);
 }
 
 // ============ DISPLAY FUNCTIONS ============
 void show_boot_screen() {
   u8g2.clearBuffer();
   u8g2.setFont(u8g2_font_logisoso16_tr);
   u8g2.drawStr(20, 28, "TinyML");
   u8g2.setFont(u8g2_font_7x13B_tr);
   u8g2.drawStr(10, 48, "Side-Channel");
   u8g2.setFont(u8g2_font_6x10_tr);
   u8g2.drawStr(30, 60, "Detector");
   u8g2.sendBuffer();
   delay(2000);
 }
 
 void show_ready_screen() {
   u8g2.clearBuffer();
   u8g2.setFont(u8g2_font_7x13B_tr);
   u8g2.drawStr(30, 28, "READY");
   u8g2.setFont(u8g2_font_6x10_tr);
   u8g2.drawStr(10, 45, "Model Loaded");
   u8g2.setCursor(10, 58);
   u8g2.print(model_data_len / 1024.0, 1);
   u8g2.print(" KB");
   u8g2.sendBuffer();
 }
 
 void update_display(int predicted_class, unsigned long latency_us) {
   u8g2.clearBuffer();
   
   // Header
   u8g2.setFont(u8g2_font_6x10_tr);
   u8g2.drawStr(0, 10, "LIVE DETECTION");
   u8g2.drawLine(0, 11, 128, 11);
   
   // Detected activity (large)
   u8g2.setFont(u8g2_font_9x15B_tr);
   u8g2.setCursor(0, 28);
   u8g2.print(activity_names[predicted_class]);
   
   // Alert indicator if not IDLE
   if (predicted_class != 0) {
     u8g2.drawFrame(0, 0, 128, 64);
     u8g2.drawFrame(1, 1, 126, 62);
     
     u8g2.setFont(u8g2_font_6x10_tr);
     u8g2.drawStr(90, 10, "ALERT");
   }
   
   // Statistics
   u8g2.setFont(u8g2_font_5x7_tr);
   u8g2.setCursor(0, 42);
   u8g2.print("Latency: ");
   u8g2.print(latency_us / 1000.0, 1);
   u8g2.print(" ms");
   
   u8g2.setCursor(0, 52);
   u8g2.print("Inferences: ");
   u8g2.print(total_inferences);
   
   // Detection counts (bar chart)
   u8g2.setCursor(0, 62);
   u8g2.print("Stats: ");
   for(int i = 0; i < 6; i++) {
     int bar_height = map(detection_count[i], 0, total_inferences/6, 0, 8);
     u8g2.drawBox(50 + i*12, 62 - bar_height, 10, bar_height);
   }
   
   u8g2.sendBuffer();
 }